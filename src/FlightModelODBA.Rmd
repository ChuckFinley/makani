---
title: "Flight Model"
author: "Max Czapanskiy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
knit: (function(inputFile, encoding) { 
         out_dir <- '../analysis/reports';
         out_file <- file.path(dirname(inputFile), out_dir, 'FlightModelNoLeg.html');
         rmarkdown::render(inputFile,
                           encoding = encoding, 
                           output_file = out_file);
       })
output: html_document
---
  
```{r setup, message = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE
)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(foreach)
library(RSQLite)
library(doParallel)
library(iterators)
library(glmmADMB)
library(knitr)
library(akima)
library(rgdal)
library(geosphere)
library(spdep)
library(mosaic)
library(mgcv)
library(lme4)

# dplyr connections
MHI_db <- src_sqlite('../data/MHI_GPS.sqlite')
metadata_db <- tbl(MHI_db, 'Metadata')
tidytracks_db <- tbl(MHI_db, 'TidyTracks')
acceleration_db <- tbl(MHI_db, 'SegmentACC')

POSIX.origin = ymd('1970-01-01', tz = 'UTC')

# Load data from earlier reports
load('../data/out/TransitSegments/Segments.RData')
load('../data/out/TransitSegments/ValidSegments.RData')
load('../data/out/TransitSegments/AccSegments.RData')
load('../data/out/TransitSegments/WindSegments.RData')

select <- dplyr::select
```

How do seabirds modulate flight behavior in response to wind? This report seeks to answer that question by modeling mean ODBA (`O`) as a function of tail- (`T`) and crosswinds (`C`) with individual bird (`B`) and trip (`R`) as random effects.

First up: segment sampling. Randomly select both an outbound and inbound segment from each eligible trip (i.e. trips _both_ outbound and inbound segments).
```{r sample_segments}
# Which trips have both outbound and inbound legs?
bothLegs <- windSegments %>%
  group_by(DeployID, TripID, Leg) %>%
  summarize(N = n()) %>%
  ungroup %>%
  spread(Leg, N) %>%
  mutate(Both = !is.na(Inbound) & !is.na(Outbound)) %>%
  filter(Both)

set.seed(211)
segSample <- windSegments %>%
  semi_join(bothLegs, by = 'TripID') %>%
  group_by(TripID, Leg) %>%
  sample_n(1) %>%
  ungroup %>%
  mutate(AirSpd = sqrt((meanSpd - Tailwind)^2 + Crosswind^2)) 

save(segSample, file = '../data/out/TransitSegments/SegSample.RData')
```

Let's look at the distribution of segments across deployments, time, and location.
```{r view_segments}
# Across deployments
ggplot(segSample, aes(x = DeployID)) +
  geom_bar() +
  labs(title = 'Segment sample: 14-48 segments from 12 individuals')

# Through time
ggplot(segSample, aes(x = Start, y = DeployID)) +
  geom_point() +
  labs(x = 'Date of Segment',
       title = 'Distribution of segments between May 28 and July 17')

# In space
ColLon <- -159.3997
ColLat <- 22.22888
LonExtent <- c(min(ColLon, segSample$Longitude), max(ColLon, segSample$Longitude))
LatExtent <- c(min(ColLat, segSample$Latitude), max(ColLat, segSample$Latitude))
hi_shp <- readOGR('../data/coastline/ne_10m_coastline/', 'ne_10m_coastline')
hi_df <- fortify(hi_shp) %>%
  filter(between(long, LonExtent[1], LonExtent[2]),
         between(lat, LatExtent[1], LatExtent[2]))
ggplot(segSample) +
  geom_path(data = hi_df, aes(x = long, y = lat, group = group)) +
  geom_point(aes(x = Longitude, y = Latitude, color = Start)) +
  coord_map() +
  theme(legend.position = 'bottom')
```

Now a look at the response varibles (O) in response to the predictor variables (T, C, A, M)
```{r plot_vars}
# O ~ T by L
ggplot(segSample, aes(x = Tailwind, y = MeanODBA, color = Leg)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Tailwind (m/s)',
       y = 'Mean ODBA',
       title = 'Mean ODBA decreases with tailwind speed') +
  theme(legend.position = 'bottom')

# O ~ C by L
ggplot(segSample, aes(x = Crosswind, y = MeanODBA, color = Leg)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Crosswind (m/s)',
       y = 'Mean ODBA',
       title = 'Mean ODBA relationship to crosswind speed varies by leg') +
  theme(legend.position = 'bottom')

# O ~ T:C
interp.seg <- with(segSample, 
                   interp(Tailwind, Crosswind, MeanODBA, nx = 40, ny = 20))
expand.grid(i = seq(interp.seg$x),
            j = seq(interp.seg$y)) %>% 
  mutate(Tailwind = sapply(i, function(a) interp.seg$x[a]),
         Crosswind = sapply(j, function(b) interp.seg$y[b]), 
         MeanODBA = mapply(function(a, b) interp.seg$z[a, b], i, j)) %>%
  ggplot(aes(x = Tailwind, y = Crosswind, fill = MeanODBA)) +
  geom_tile() +
  geom_abline(intercept = 0, slope = c(-1, 1)) +
  scale_x_continuous(breaks = seq(-12, 12, by = 3)) +
  scale_y_continuous(breaks = seq(0, 12, by = 3)) +
  scale_fill_distiller(palette = 'RdBu') +
  coord_fixed(xlim = c(-12, 12),
              ylim = c(0, 12)) +
  labs(title = 'Interpolated Mean ODBAs by Tail/Crosswind')

# O ~ A by L
ggplot(segSample, aes(x = WindAngle, y = MeanODBA, color = Leg)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Wind Angle',
       y = 'Mean ODBA',
       title = 'Mean ODBA decreases with tailwinds, flat with headwinds') +
  theme(legend.position = 'bottom') +
  scale_x_continuous(breaks = pi/4 *0:4,
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'),
                     name = 'Tailwind  <---  Wind Angle  --->  Headwind')

# O ~ S by L
ggplot(segSample, aes(x = WindSpd, y = MeanODBA, color = Leg)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Wind Speed (m/s)',
       y = 'Mean ODBA',
       title = 'Mean ODBA unresponsive to wind speed alone') +
  theme(legend.position = 'bottom')

# O ~ A:S
interp.seg2 <- with(segSample, 
                    interp(WindAngle, WindSpd, MeanODBA, nx = 40, ny = 20))
expand.grid(i = seq(interp.seg2$x),
            j = seq(interp.seg2$y)) %>% 
  mutate(WindAngle = sapply(i, function(a) interp.seg2$x[a]),
         WindSpd = sapply(j, function(b) interp.seg2$y[b]), 
         MeanODBA = mapply(function(a, b) interp.seg2$z[a, b], i, j)) %>%
  ggplot(aes(x = WindAngle, y = WindSpd, fill = MeanODBA)) +
  geom_tile() +
  scale_x_continuous(breaks = pi/4 *0:4,
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'),
                     name = 'Tailwind  <---  Wind Angle  --->  Headwind') +
  scale_y_continuous(breaks = seq(5, 10, by = 3)) +
  scale_fill_distiller(palette = 'RdBu') +
  labs(title = 'Interpolated Mean ODBAs by Wind Speed/Angle')
```

## Determine random effects structure
Starting with the maximal fixed effects model (`O ~ T * C`) rank the potential random effects structures (where TripID < DeployID) by AIC

```{r setup_re1}
# List to store random effects model formulae
re.form <- list()
# Formula of maximal fixed effects
fe.max <- MeanODBA ~ Tailwind * Crosswind

# Intercepts
re.form[[1]] <- ~ . + (1|DeployID)
re.form[[2]] <- ~ . + (1|TripID)

# Slopes by DeployID
re.form[[3]] <- ~ . +  (Tailwind|DeployID)
re.form[[4]] <- ~ . + (Crosswind|DeployID)
re.form[[5]] <- ~ . + (Tailwind|DeployID) + (Crosswind|DeployID)

# Slopes by TripID
re.form[[6]] <- ~ . + (Tailwind|TripID)
re.form[[7]] <- ~ . + (Crosswind|TripID)
re.form[[8]] <- ~ . + (Tailwind|TripID) + (Crosswind|TripID)

# Interaction by DeployID and TripID
re.form[[9]] <- ~ . + (Tailwind:Crosswind|DeployID)
re.form[[10]] <- ~ . + (Tailwind:Crosswind|TripID)

# Function for converting formulae to strings
char.formula <- function(f) {
  mod.parts <- as.character(f) %>%
    gsub('MeanODBA', 'O', .) %>%
    gsub('Tailwind', 'T', .) %>%
    gsub('Crosswind', 'C', .) %>%
    gsub('MeanSpd', 'S', .) %>%
    gsub('WindAngle', 'A', .) %>%
    gsub('DeployID', 'B', .) %>%
    gsub('TripID', 'R', .)
  if(length(mod.parts) == 2)
    paste(mod.parts, collapse = ' ')
  else
    paste(mod.parts[1], mod.parts[3])
}
```

```{r setup_re2}
# List to store random effects model formulae
re.form <- list()
# Formula of maximal fixed effects
fe.max <- MeanODBA ~ WindAngle * WindSpd

# Intercepts
re.form[[1]] <- ~ . + (1|DeployID)
re.form[[2]] <- ~ . + (1|TripID)

# Slopes by DeployID
re.form[[3]] <- ~ . +  (WindAngle|DeployID)
re.form[[4]] <- ~ . + (WindSpd|DeployID)
re.form[[5]] <- ~ . + (WindAngle|DeployID) + (WindSpd|DeployID)

# Slopes by TripID
re.form[[6]] <- ~ . + (WindAngle|TripID)
re.form[[7]] <- ~ . + (WindSpd|TripID)
re.form[[8]] <- ~ . + (WindAngle|TripID) + (WindSpd|TripID)

# Interaction by DeployID and TripID
re.form[[9]] <- ~ . + (WindAngle:WindSpd|DeployID)
re.form[[10]] <- ~ . + (WindAngle:WindSpd|TripID)
```

```{r fit_random_effects, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
re.mod <- foreach(f = re.form) %dopar% {
  mod.formula <- update.formula(fe.max, f)
  tryCatch(glmmadmb(mod.formula, segSample, family = 'beta'), error = function(e) NULL)
}
stopCluster(modCl)

# Save random effects models
save(re.mod, file = '../data/out/Models/REmodelsNoLeg.RData')
```

```{r summ_random_effects}
load('../data/out/Models/REmodelsNoLeg.RData')
# Summarize models by AIC
re.summ <- foreach(f = re.form,
                   m = re.mod, 
                   .combine = rbind) %do% {
  re.formula <- char.formula(f)
  if(is.null(m)) {
    data.frame(Formula = re.formula,
               AIC = NA)
  } else {
    data.frame(Formula = re.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(re.summ, digits = 3)
```

Based on AICw the top ranked random effects structures are `(1|B)` and `(T:C|B)`. `(C|B)` and `(T|B)` also delta AIC less than 2. We'll try all four in determining fixed effects structure.

## Determine fixed effects structure
Using the optimal random effects structures, determine best fitting fixed effects structure
```{r setup_mixed_effects}
# List to store fixed effects model formulae
me.form <- list()
# Formulae of optimal random effects structures
re.optim1 <- FlapRatio ~ (1|DeployID)
re.optim2 <- FlapRatio ~ (Tailwind:Crosswind|DeployID)
re.optim3 <- FlapRatio ~ (Crosswind|DeployID)
re.optim4 <- FlapRatio ~ (Tailwind|DeployID)

# Mixed effects to test with (1|B)
me.form[[1]] <- list(~ . + Tailwind * Crosswind, re.optim1)
me.form[[2]] <- list(~ . + Tailwind + Crosswind, re.optim1)
me.form[[3]] <- list(~ . + Tailwind, re.optim1)
me.form[[4]] <- list(~ . + Crosswind, re.optim1)

# Mixed effects to test with (T:C|B)
me.form[[5]] <- list(~ . + Tailwind * Crosswind, re.optim2)
me.form[[6]] <- list(~ . + Tailwind + Crosswind, re.optim2)

# Mixed effects to test with (C|B)
me.form[[7]] <- list(~ . + Tailwind * Crosswind, re.optim3)
me.form[[8]] <- list(~ . + Tailwind + Crosswind, re.optim3)
me.form[[9]] <- list(~ . + Crosswind, re.optim3)

# Mixed effects to test with (T|B)
me.form[[10]] <- list(~ . + Tailwind * Crosswind, re.optim4)
me.form[[11]] <- list(~ . + Tailwind + Crosswind, re.optim4)
me.form[[12]] <- list(~ . + Tailwind, re.optim4)
```

```{r fit_mixed_effects, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
me.mod <- foreach(f = me.form,
                  i = seq_along(re.form)) %dopar% {
  # Update 
  mod.formula <- update.formula(f[[2]], f[[1]])
  tryCatch(glmmadmb(mod.formula, segSample, family = 'beta'), error = function(e) NULL)
}
stopCluster(modCl)

# Save mixed effects models
save(me.mod, file = '../data/out/Models/MEmodelsNoLeg.RData')
```

```{r summ_mixed_effects, fig.width=8, fig.height=8}
load('../data/out/Models/MEmodelsNoLeg.RData')
# Summarize models by AIC
me.summ <- foreach(f = me.form,
                   m = me.mod, 
                   .combine = rbind) %do% {
  fe.formula <- char.formula(f[[1]])
  re.formula <- char.formula(f[[2]])
  
  if(is.null(m)) {
    data.frame(FixedEffects = fe.formula,
               RandomEffects = re.formula,
               AIC = NA)
  } else {
    data.frame(FixedEffects = fe.formula,
               RandomEffects = re.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(me.summ, digits = 3)

# Compare actual/predicted distributions
mod.rank <- foreach(f = me.form,
                    m = me.mod,
                    .combine = rbind) %do% {
  data.frame(mod.lbl = paste(char.formula(f[[1]]), char.formula(f[[2]])),
             mod.aic = AIC(m))
} %>%
  mutate(mod.rank = rank(mod.aic))
foreach(f = me.form,
        m = me.mod,
        .combine = rbind) %do% {
  data.frame(mod.lbl = paste(char.formula(f[[1]]), char.formula(f[[2]])),
             mod.fitted = m$fitted)
} %>%
  left_join(mod.rank) %>%
  ggplot(aes(x = mod.fitted)) +
  geom_density(color = '#AA0000') +
  facet_wrap(~ mod.lbl) +
  geom_density(data = me.mod[[1]]$frame, 
               aes(x = FlapRatio),
               fill = '#0000AA',
               alpha = 0.5) +
  geom_text(aes(label = mod.rank), x = 0.1, y = 5) +
  labs(x = 'Flap Ratio',
       y = 'Density Function',
       title = 'Fiitted vs. Actual Flap Ratio Distribution',
       caption = 'Blue fill = actual, red line = fitted, number = rank')

# Residuals vs fitted
foreach(f = me.form,
        m = me.mod,
        .combine = rbind) %do% {
  data.frame(mod.lbl = paste(char.formula(f[[1]]), char.formula(f[[2]])),
             mod.resid = m$residuals,
             mod.fit = m$fitted)
} %>%
  left_join(mod.rank) %>%
  ggplot(aes(x = mod.fit, y = mod.resid)) +
  geom_point() +
  geom_smooth() +
  geom_text(aes(label = mod.rank), x = 0.2, y = -0.25) +
  facet_wrap(~ mod.lbl) +
  labs(title = 'Residuals vs fitted values',
       caption = 'Number = rank')

# QQ plots
foreach(f = me.form,
        m = me.mod,
        .combine = rbind) %do% {
  data.frame(mod.lbl = paste(char.formula(f[[1]]), char.formula(f[[2]])),
             mod.resid = m$residuals)
} %>%
  left_join(mod.rank) %>%
  ggplot(aes(sample = mod.resid / sd(mod.resid))) +
  stat_qq() +
  geom_abline(slope = 1, intercept = 0, color = 'darkred') +
  facet_wrap(~ mod.lbl) +
  geom_text(aes(label = mod.rank), x = -2, y = 2) +
  labs(title = 'Residual Q-Q plots')
```

The highest ranking mixed effects models are `F ~ T * C + (1 | B)` and `F ~ T * C + (T:C | B)`. The latter has more homogeneous residuals, so we will use that as the flight model.

## Model diagnostics
```{r mod_summ}
flight.model <- me.mod[[5]]
summary(flight.model)

# Histogram of residuals
data.frame(residuals = residuals(flight.model)) %>%
  ggplot(aes(x = residuals)) +
  geom_histogram(binwidth = 0.1) +
  geom_vline(xintercept = 0, color = 'red') +
  labs(title = 'Distribution of residuals')

# Residuals vs fitted
data.frame(residuals = residuals(flight.model),
           fitted = fitted(flight.model)) %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_point() +
  geom_smooth() +
  labs(title = 'Residuals vs fitted values')

# Random effect coefficient distributions
flight.model.ranef <- data.frame(ranef(flight.model)$DeployID)
colnames(flight.model.ranef) <- c('Intercept', 'TailCross')
flight.model.ranef %>%
  mutate_all(function(x) (x - mean(x)) / sd(x)) %>%
  gather(RandomEffect, Value, Intercept:TailCross) %>%
  ggplot(aes(x = RandomEffect, y = Value)) +
  geom_boxplot() +
  labs(x = 'Random Effect',
       y = 'Normalized Regression Estimates',
       title = 'Range of Normalized Random Effect Coefficients')
## TODO: how is this usually done in journals?
```

```{r vs.leg}
# Just checking, is no-leg model better than with-leg model?
with.leg <- glmmadmb(FlapRatio ~ Tailwind * Crosswind * Leg + (Crosswind:Leg|DeployID), 
                     segSample, 
                     family = 'beta')
sprintf('AIC of no-leg model = %.2f, AIC of leg model = %.2f', AIC(flight.model), AIC(with.leg))
sprintf('delta AIC (no-leg minus leg) = %.2f', AIC(flight.model) - AIC(with.leg))

# no-leg model has a better AIC. But so many "insignificant" terms. Is the parsimony significant?
anova(flight.model, with.leg)

# Are residuals spatially autocorrelated?
# Append residuals to locations
resid.loc <- segSample %>%
  mutate(noleg.resid = resid(flight.model),
         withleg.resid = resid(with.leg),
         Dist2Col = distGeo(c(ColLon, ColLat), cbind(Longitude, Latitude))) %>%
  select(Longitude, Latitude, Dist2Col, noleg.resid, withleg.resid)
# Calculate inverse distance spatial weights matrix
id.swm <- outer(seq(nrow(resid.loc)), seq(nrow(resid.loc)), 
                function(i, j) {
                  1 / distGeo(cbind(resid.loc$Longitude[i], resid.loc$Latitude[i]),
                              cbind(resid.loc$Longitude[j], resid.loc$Latitude[j]))
                  })
id.swm[is.infinite(id.swm)] <- 0
# Calculate Moran's I
moran.test(resid.loc$withleg.resid, mat2listw(id.swm))
moran.test(resid.loc$noleg.resid, mat2listw(id.swm))
# Both sets of residuals are auto-correlated

# In space
ggplot(resid.loc) +
  geom_polygon(data = hi_df, aes(x = long, y = lat, group = group), fill = 'white') +
  geom_point(aes(x = Longitude, y = Latitude, color = withleg.resid)) +
  coord_map() +
  scale_color_distiller(palette = 'RdBu') +
  theme(legend.position = 'bottom',
        panel.background = element_rect(fill = 'darkgrey'))
```

## Model predictions
```{r mod.pred}
cardinality <- 30
model.predictions <- expand.grid(Tailwind = seq(-12, 12, length.out = cardinality),
                                 Crosswind = seq(0, 12, length.out = cardinality)) %>%
  mutate(FlapRatio = predict(flight.model, newdata = ., type = 'response'))

# Get convex hulls of original data
segHulls <- segSample %>%
  do({
    pt_order <- with(., chull(Tailwind, Crosswind))
    pt_order_closed <- c(pt_order, pt_order[1])
    data.frame(Tailwind = .$Tailwind[pt_order_closed],
               Crosswind = .$Crosswind[pt_order_closed],
               stringsAsFactors = FALSE)
  })
 
# With original data extent
ggplot(model.predictions, aes(x = Tailwind, y = Crosswind)) +
  geom_tile(aes(fill = FlapRatio)) +
  geom_polygon(data = segHulls, fill = 'darkgrey', alpha = 0.55) +
  geom_contour(aes(z = FlapRatio)) +
  scale_fill_distiller(type = 'div', palette = 'RdBu', limits = c(0.2, 0.5)) +
  labs(fill = 'Flap Ratio',
       title = 'Flight Model Predictions',
       caption = 'Shaded area indicates extent of original data\nContours in blue')

# Without original data extent
ggplot(model.predictions, aes(x = Tailwind, y = Crosswind)) +
  geom_tile(aes(fill = FlapRatio)) +
  geom_contour(aes(z = FlapRatio)) +
  scale_fill_distiller(type = 'div', palette = 'RdBu', limits = c(0.2, 0.5)) +
  labs(fill = 'Flap Ratio',
       title = 'Flight Model Predictions',
       caption = 'Contours in blue')
```

What's the mean speed and flap ratio of transit segments?
```{r}
segSample %>%
  summarize(mean(meanSpd))

speed.model <- lm(meanSpd ~ Tailwind, data = segSample)
summary(speed.model)
ggplot(segSample, aes(x = Tailwind, y = meanSpd)) +
  geom_point() +
  geom_smooth(method = 'lm', alpha = 0) +
  coord_fixed() +
  labs(x = 'Tailwind speed (m/s)',
       y = 'Ground speed (m/s)')

summary(segSample$FlapRatio)
```

Wind selection
```{r}
# More segments were in tail-/headwinds than crosswinds
segSample %>%
  mutate(WindAngle = derivedFactor(Headwind = -Tailwind >= Crosswind,
                                   Tailwind = Tailwind >= Crosswind,
                                   Crosswind = abs(Tailwind) < Crosswind)) %>%
  ggplot(aes(x = WindAngle)) +
  geom_bar()

segSample2 <- mutate(segSample, 
                     WindAngle = atan2(Crosswind, Tailwind),
                     AirSpeed = sqrt((meanSpd - Tailwind)^2 + Crosswind^2))

# Flap ratio decreases as tailwinds increase, but flat in all headwinds
ggplot(segSample2, aes(x = WindAngle, y = FlapRatio)) +
  geom_smooth(method = 'gam', formula = y ~ s(x)) +
  geom_point() +
  scale_x_continuous(breaks = pi/4 *0:4, 
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'))

flap.gam <- gamm(FlapRatio ~ s(WindAngle), 
                 random = list(DeployID = ~1), 
                 family = gaussian(link = 'identity'),
                 data = segSample2)

# Air speed
ggplot(segSample2, aes(x = Tailwind, y = AirSpeed, color = Crosswind)) +
  geom_point() +
  geom_smooth(method = 'gam', formula = y ~ s(x)) +
  scale_color_distiller(palette = 'RdBu')

airspd.lm <- lmer(AirSpeed ~ Tailwind + (1|DeployID), data = segSample2)
mutate(segSample2,
       airspd.resid = resid(airspd.lm)) %>%
  ggplot(aes(sample = airspd.resid / sd(airspd.resid))) +
  stat_qq() +
  geom_abline(slope = 1, intercept = 0, color = 'darkred') +
  labs(title = 'Residual Q-Q plots') +
  coord_fixed()

wind.spd <- 8.1 # m/s
mass <- 1060 # g
distance <- 100e3 # m
# Assume work is a weighted average of flap/glide. See Duerr et al. 2012 for flap/glide
# power ratio. See Raymond et al. 2010 for E ~ Va. See Ballance 1995 for RFBO parameters
W <- function(Va) {
  S <- 0.2 # m^2
  q <- 9.7 # W (RMR)
  # What's r?
  q + 1/Va + S * Va^3
}
Wfg <- function(fg, Va) {
  w <- W(Va)
  w * mass ^ 1.17 * fg + w * mass ^ 0.78 * (1 - fg)
}
E <- function(W, d, Vg) {
  W * d / Vg
}
Vg <- function(Va, t, c) {
  sqrt(Va^2 - c^2) + t
}
Va <- function(t) {
  predict(airspd.lm, newdata = data.frame(Tailwind = t), re.form = NA)
}
foo <- data.frame(windAngle = seq(0, pi, length.out = 20)) %>%
  mutate(TOut = wind.spd * cos(windAngle),
         TIn = wind.spd * cos(pi - windAngle),
         COut = wind.spd * sin(windAngle),
         CIn = wind.spd * sin(pi - windAngle),
         FOut = predict(flap.gam$gam, 
                        newdata = data.frame(WindAngle = windAngle)),
         FIn = predict(flap.gam$gam, 
                       newdata = data.frame(WindAngle = pi - windAngle)),
         FNet = (FOut + FIn) / 2,
         VaOut = Va(TOut),
         VaIn = Va(TIn),
         VgOut = Vg(VaOut, TOut, COut),
         VgIn = Vg(VaIn, TIn, CIn),
         WOut = Wfg(FOut, VaOut),
         WIn = Wfg(FIn, VaIn),
         EOut = E(WOut, distance, VgOut),
         EIn = E(WIn, distance, VgIn),
         ETot = EOut + EIn)

foo %>%
  gather(key = Direction, value = energy, EOut:ETot) %>%
  ggplot(aes(x = windAngle, y = energy, color = Direction)) +
  geom_line() +
  scale_x_continuous(breaks = pi/4 *0:4, 
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'))
```
