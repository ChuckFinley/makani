---
title: "Flight Model"
author: "Max Czapanskiy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
knit: (function(inputFile, encoding) { 
         out_dir <- '../analysis/reports';
         out_file <- file.path(dirname(inputFile), out_dir, 'FlightModelNoLeg.html');
         rmarkdown::render(inputFile,
                           encoding = encoding, 
                           output_file = out_file);
       })
output: html_document
---
  
```{r setup, message = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)
library(dplyr)
library(lubridate)
library(tidyr)
library(ggplot2)
library(foreach)
library(RSQLite)
library(doParallel)
library(iterators)
library(glmmADMB)
library(knitr)
library(akima)
library(rgdal)
library(geosphere)
library(spdep)
library(mosaic)
library(rlang)

# dplyr connections
MHI_db <- src_sqlite('../data/MHI_GPS.sqlite')
metadata_db <- tbl(MHI_db, 'Metadata')
tidytracks_db <- tbl(MHI_db, 'TidyTracks')
acceleration_db <- tbl(MHI_db, 'SegmentACC')

POSIX.origin = ymd('1970-01-01', tz = 'UTC')

# Load data from earlier reports
load('../data/out/TransitSegments/Segments.RData')
load('../data/out/TransitSegments/ValidSegments.RData')
load('../data/out/TransitSegments/AccSegments.RData')
load('../data/out/TransitSegments/WindSegments.RData')

select <- dplyr::select
```

How do seabirds modulate flight behavior in response to wind? This report seeks to answer that question by modeling the flap ratio as a function of tail- (`T`) and crosswinds (`C`) with individual bird (`B`) and trip (`R`) as random effects.

First up: segment sampling. Randomly select both an outbound and inbound segment from each eligible trip (i.e. trips _both_ outbound and inbound segments).
```{r sample_segments}
# Which trips have both outbound and inbound legs?
bothLegs <- windSegments %>%
  group_by(DeployID, TripID, Leg) %>%
  summarize(N = n()) %>%
  ungroup %>%
  spread(Leg, N) %>%
  mutate(Both = !is.na(Inbound) & !is.na(Outbound)) %>%
  filter(Both)

set.seed(211)
segSample <- windSegments %>%
  semi_join(bothLegs, by = 'TripID') %>%
  group_by(TripID, Leg) %>%
  sample_n(1) %>%
  ungroup %>%
  mutate(AirSpd = sqrt((meanSpd - Tailwind)^2 + Crosswind^2),
         Leg = factor(Leg)) 

save(segSample, file = '../data/out/TransitSegments/SegSample.RData')
```

Let's look at the distribution of segments across deployments, time, and location.
```{r view_segments}
# Across deployments
ggplot(segSample, aes(x = DeployID)) +
  geom_bar() +
  labs(title = 'Segment sample: 14-48 segments from 12 individuals')

# Through time
ggplot(segSample, aes(x = Start, y = DeployID)) +
  geom_point() +
  labs(x = 'Date of Segment',
       title = 'Distribution of segments between May 28 and July 17')

# In space
ColLon <- -159.3997
ColLat <- 22.22888
LonExtent <- c(min(ColLon, segSample$Longitude), max(ColLon, segSample$Longitude))
LatExtent <- c(min(ColLat, segSample$Latitude), max(ColLat, segSample$Latitude))
hi_shp <- readOGR('../data/coastline/ne_10m_coastline/', 'ne_10m_coastline')
hi_df <- fortify(hi_shp) %>%
  filter(between(long, LonExtent[1], LonExtent[2]),
         between(lat, LatExtent[1], LatExtent[2]))
ggplot(segSample) +
  geom_path(data = hi_df, aes(x = long, y = lat, group = group)) +
  geom_point(aes(x = Longitude, y = Latitude, color = Start)) +
  coord_map() +
  theme(legend.position = 'bottom')
```

Now a look at the response varibles (F, O) in response to the predictor variables (T, C, A, M)
```{r plot_vars_FV}
# F ~ T
ggplot(segSample, aes(x = Tailwind, y = FlapRatio)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Tailwind (m/s)',
       y = 'Flap Ratio') +
  theme(legend.position = 'bottom')

# F ~ C
ggplot(segSample, aes(x = Crosswind, y = FlapRatio, color = factor(Tailwind > 0, labels = c('Tailwind', 'Headwind')))) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Crosswind (m/s)',
       y = 'Flap Ratio',
       color = 'Tailwind/Headwind') +
  theme(legend.position = 'bottom')

# F ~ T:C
ggplot(segSample, aes(x = Tailwind * Crosswind, y = FlapRatio)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Tailwind * Crosswind (m^2/s^2)',
       y = 'Flap Ratio',
       title = 'Flap ratio relationship to tailwind:crosswind') +
  theme(legend.position = 'bottom')

Cross <- seq(0, 11, by = 1); Cstep <- Cross[2] - Cross[1];
Tail <- seq(-11, 11, by = 1); Tstep <- Tail[2] - Tail[1];
expand.grid(Crosswind = Cross, Tailwind = Tail) %>%
  mutate(FlapRatio = mapply(Tailwind, Crosswind,
                            FUN = function(T1, C1) {
                              points <- filter(segSample,
                                               Tailwind >= T1,
                                               Tailwind < T1 + Tstep,
                                               Crosswind >= C1,
                                               Crosswind < C1 + Cstep)
                              if(nrow(points) == 0) 
                                NA 
                              else
                                mean(points$FlapRatio, na.rm = TRUE)
                            })) %>% 
  ggplot(aes(x = Tailwind, y = Crosswind, fill = FlapRatio)) +
  geom_raster() +
  scale_fill_distiller(palette = 'RdYlBu')
```

```{r plot_vars_FS}
# F ~ A
ggplot(segSample, aes(x = WindAngle, y = FlapRatio, color = WindSpd)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Wind Angle',
       y = 'FlapRatio') +
  theme(legend.position = 'bottom') +
  scale_x_continuous(breaks = pi/4 *0:4,
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'),
                     name = 'Tailwind  <---  Wind Angle  --->  Headwind')

# F ~ M
ggplot(segSample, aes(x = WindSpd, y = FlapRatio, color = WindAngle)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Wind Magnitude (m/s)',
       y = 'FlapRatio')

# F ~ A * M
A <- seq(0, pi, length.out = 10)
Astep <- A[2] - A[1]
M <- seq(0, 12, by = 1)
Mstep <- M[2] - M[1];
expand.grid(WindAngle = A, WindSpd = M) %>%
  mutate(FlapRatio = mapply(WindAngle, WindSpd,
                            FUN = function(A1, M1) {
                              points <- filter(segSample,
                                               WindAngle >= A1,
                                               WindAngle < A1 + Astep,
                                               WindSpd >= M1,
                                               WindSpd < M1 + Mstep)
                              if(nrow(points) == 0) 
                                NA 
                              else
                                mean(points$FlapRatio, na.rm = TRUE)
                            })) %>% 
  ggplot(aes(x = WindAngle, y = WindSpd, fill = FlapRatio)) +
  geom_raster() +
  scale_fill_distiller(palette = 'RdYlBu') + 
  scale_x_continuous(breaks = pi/4 *0:4,
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'),
                     name = 'Tailwind  <---  Wind Angle  --->  Headwind')
```

```{r plot_vars_OV}
# O ~ T
ggplot(segSample, aes(x = Tailwind, y = MeanODBA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Tailwind (m/s)',
       y = 'ODBA (m/s^2)') +
  theme(legend.position = 'bottom')

# O ~ C
ggplot(segSample, aes(x = Crosswind, y = MeanODBA, color = factor(Tailwind > 0, labels = c('Tailwind', 'Headwind')))) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Crosswind (m/s)',
       y = 'ODBA (m/s^2)',
       color = 'Tailwind/Headwind') +
  theme(legend.position = 'bottom')

# O ~ T:C
ggplot(segSample, aes(x = Tailwind * Crosswind, y = MeanODBA)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Tailwind * Crosswind (m^2/s^2)',
       y = 'ODBA (m/s^2)') +
  theme(legend.position = 'bottom')

Cross <- seq(0, 11, by = 1); Cstep <- Cross[2] - Cross[1];
Tail <- seq(-11, 11, by = 1); Tstep <- Tail[2] - Tail[1];
expand.grid(Crosswind = Cross, Tailwind = Tail) %>%
  mutate(MeanODBA = mapply(Tailwind, Crosswind,
                            FUN = function(T1, C1) {
                              points <- filter(segSample,
                                               Tailwind >= T1,
                                               Tailwind < T1 + Tstep,
                                               Crosswind >= C1,
                                               Crosswind < C1 + Cstep)
                              if(nrow(points) == 0) 
                                NA 
                              else
                                mean(points$MeanODBA, na.rm = TRUE)
                            })) %>% 
  ggplot(aes(x = Tailwind, y = Crosswind, fill = MeanODBA)) +
  geom_raster() +
  scale_fill_distiller(palette = 'RdYlBu')
```

```{r plot_vars_OS}
# O ~ A
ggplot(segSample, aes(x = WindAngle, y = MeanODBA, color = WindSpd)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Wind Angle',
       y = 'ODBA (m/s^2)') +
  theme(legend.position = 'bottom') +
  scale_x_continuous(breaks = pi/4 *0:4,
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'),
                     name = 'Tailwind  <---  Wind Angle  --->  Headwind')

# O ~ M
ggplot(segSample, aes(x = WindSpd, y = MeanODBA, color = WindAngle)) +
  geom_point() +
  geom_smooth(method = 'loess') +
  labs(x = 'Wind Magnitude (m/s)',
       y = 'ODBA (m/s^2)')

# O ~ A * M
A <- seq(0, pi, length.out = 10)
Astep <- A[2] - A[1]
M <- seq(0, 12, by = 1)
Mstep <- M[2] - M[1];
expand.grid(WindAngle = A, WindSpd = M) %>%
  mutate(ODBA = mapply(WindAngle, WindSpd,
                            FUN = function(A1, M1) {
                              points <- filter(segSample,
                                               WindAngle >= A1,
                                               WindAngle < A1 + Astep,
                                               WindSpd >= M1,
                                               WindSpd < M1 + Mstep)
                              if(nrow(points) == 0) 
                                NA 
                              else
                                mean(points$MeanODBA, na.rm = TRUE)
                            })) %>% 
  ggplot(aes(x = WindAngle, y = WindSpd, fill = ODBA)) +
  geom_raster() +
  scale_fill_distiller(palette = 'RdYlBu') + 
  scale_x_continuous(breaks = pi/4 *0:4,
                     labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'),
                     name = 'Tailwind  <---  Wind Angle  --->  Headwind')

```

# Model Fitting (FV)
## Determine optimal random effects structure (from DeployID, Leg)

```{r setup_re_fv}
# Function for converting formulae to strings
char.formula <- function(f) {
  mod.parts <- as.character(f) %>%
    gsub('FlapRatio', 'F', .) %>%
    gsub('MeanODBA', 'O', .) %>%
    gsub('Tailwind', 'T', .) %>%
    gsub('Crosswind', 'C', .) %>%
    gsub('WindAngle', 'A', .) %>%
    gsub('WindSpd', 'M', .) %>%
    gsub('Leg', 'L', .) %>%
    gsub('DeployID', 'B', .)
  if(length(mod.parts) == 2)
    paste(mod.parts, collapse = ' ')
  else
    paste(mod.parts[1], mod.parts[3])
}

fe.fv.max <- FlapRatio ~ poly(Tailwind, 2) * Crosswind
re.fv.form <- list(~ . + (1|DeployID),
                   ~ . + (1|Leg))
```

```{r fit_re_fv, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
re.fv.mod <- foreach(f = re.fv.form) %dopar% {
  mod.formula <- update.formula(fe.fv.max, f)
  tryCatch(glmmadmb(mod.formula, segSample, family = 'beta'), error = function(e) NULL)
}
stopCluster(modCl)

# Save random effects models
save(re.fv.mod, file = '../data/out/Models/REFVmodels.RData')
```

```{r summarize_re_fv}
load('../data/out/Models/REFVmodels.RData')
# Summarize models by AIC
re.fv.summ <- foreach(f = re.fv.form,
                   m = re.fv.mod, 
                   .combine = rbind) %do% {
  re.fv.formula <- char.formula(f)
  if(is.null(m)) {
    data.frame(Formula = re.fv.formula,
               AIC = NA)
  } else {
    data.frame(Formula = re.fv.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(re.fv.summ, digits = 3)
```

Based on AIC the top ranked FV random effects structure is (1|B).

## Determine optimal fixed effects structure
Using the optimal random effects structure, determine best fitting fixed effects structure
```{r setup_fe_fv}
# Formulae of optimal random effects structure
re.fv.optim <- FlapRatio ~ (1|DeployID)
# List to store fixed effects model formulae
me.fv.form <- list(list(~ . + poly(Tailwind, 2) * Crosswind, re.fv.optim),
                   list(~ . + poly(Tailwind, 2) + Crosswind, re.fv.optim),
                   list(~ . + poly(Tailwind, 2), re.fv.optim),
                   list(~ . + Crosswind, re.fv.optim))
```

```{r fit_me_fv, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
me.fv.mod <- foreach(f = me.fv.form) %dopar% {
  # Update 
  mod.formula <- update.formula(f[[2]], f[[1]])
  tryCatch(glmmadmb(mod.formula, segSample, family = 'beta'), error = function(e) NULL)
}
stopCluster(modCl)

# Save mixed effects models
save(me.fv.mod, file = '../data/out/Models/MEFVmodels.RData')
```

```{r summarize_me_fv}
load('../data/out/Models/MEFVmodels.RData')
# Summarize models by AIC
me.fv.summ <- foreach(f = me.fv.form,
                      m = me.fv.mod, 
                      .combine = rbind) %do% {
  fe.fv.formula <- char.formula(f[[1]])
  re.fv.formula <- char.formula(f[[2]])
  
  if(is.null(m)) {
    data.frame(FixedEffects = fe.fv.formula,
               RandomEffects = re.fv.formula,
               AIC = NA)
  } else {
    data.frame(FixedEffects = fe.fv.formula,
               RandomEffects = re.fv.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(me.fv.summ, digits = 3)
```

# Model Fitting (FS)
## Determine optimal random effects structure (from DeployID, Leg)

```{r setup_re_fs}
fe.fs.max <- FlapRatio ~ poly(WindAngle, 2) * WindSpd
re.fs.form <- list(# Intercepts
                   ~ . + (1|DeployID),
                   ~ . + (1|Leg))
```

```{r fit_re_fs, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
re.fs.mod <- foreach(f = re.fs.form) %dopar% {
  mod.formula <- update.formula(fe.fs.max, f)
  tryCatch(glmmadmb(mod.formula, segSample, family = 'beta'), error = function(e) NULL)
}
stopCluster(modCl)

# Save random effects models
save(re.fs.mod, file = '../data/out/Models/REFSmodels.RData')
```

```{r summarize_re_fs}
load('../data/out/Models/REFSmodels.RData')
# Summarize models by AIC
re.fs.summ <- foreach(f = re.fs.form,
                   m = re.fs.mod, 
                   .combine = rbind) %do% {
  re.fs.formula <- char.formula(f)
  if(is.null(m)) {
    data.frame(Formula = re.fs.formula,
               AIC = NA)
  } else {
    data.frame(Formula = re.fs.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(re.fs.summ, digits = 3)
```

Based on AIC the top ranked FV random effects structure is (1|B).

## Determine optimal fixed effects structure
Using the optimal random effects structure, determine best fitting fixed effects structure
```{r setup_fe_fs}
# Formulae of optimal random effects structure
re.fs.optim <- FlapRatio ~ (1|DeployID)
# List to store fixed effects model formulae
me.fs.form <- list(# RE1
                   list(~ . + poly(WindAngle, 2) * WindSpd, re.fs.optim),
                   list(~ . + poly(WindAngle, 2) + WindSpd, re.fs.optim),
                   list(~ . + poly(WindAngle, 2), re.fs.optim),
                   list(~ . + WindSpd, re.fs.optim))
```

```{r fit_me_fs, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
me.fs.mod <- foreach(f = me.fs.form) %dopar% {
  # Update 
  mod.formula <- update.formula(f[[2]], f[[1]])
  tryCatch(glmmadmb(mod.formula, segSample, family = 'beta'), error = function(e) NULL)
}
stopCluster(modCl)

# Save mixed effects models
save(me.fs.mod, file = '../data/out/Models/MEFSmodels.RData')
```

```{r summarize_me_fs}
load('../data/out/Models/MEFSmodels.RData')
# Summarize models by AIC
me.fs.summ <- foreach(f = me.fs.form,
                      m = me.fs.mod, 
                      .combine = rbind) %do% {
  fe.fs.formula <- char.formula(f[[1]])
  re.fs.formula <- char.formula(f[[2]])
  
  if(is.null(m)) {
    data.frame(FixedEffects = fe.fs.formula,
               RandomEffects = re.fs.formula,
               AIC = NA)
  } else {
    data.frame(FixedEffects = fe.fs.formula,
               RandomEffects = re.fs.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(me.fs.summ, digits = 3)
```

# Model Fitting (OV)
## Determine optimal random effects structure (from DeployID, Leg)

```{r setup_re_ov}
fe.ov.max <- MeanODBA ~ poly(Tailwind, 2) * Crosswind
re.ov.form <- list(# Intercepts
                   ~ . + (1|DeployID),
                   ~ . + (1|Leg))
```

```{r fit_re_ov, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
re.ov.mod <- foreach(f = re.ov.form) %dopar% {
  mod.formula <- update.formula(fe.ov.max, f)
  tryCatch(glmmadmb(mod.formula, segSample, family = 'gaussian'), error = function(e) NULL)
}
stopCluster(modCl)

# Save random effects models
save(re.ov.mod, file = '../data/out/Models/REOVmodels.RData')
```

```{r summarize_re_ov}
load('../data/out/Models/REOVmodels.RData')
# Summarize models by AIC
re.ov.summ <- foreach(f = re.ov.form,
                   m = re.ov.mod, 
                   .combine = rbind) %do% {
  re.ov.formula <- char.formula(f)
  if(is.null(m)) {
    data.frame(Formula = re.ov.formula,
               AIC = NA)
  } else {
    data.frame(Formula = re.ov.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(re.ov.summ, digits = 3)
```

Based on AIC the top ranked OV random effects structure is (1|B).

## Determine optimal fixed effects structure
Using the optimal random effects structure, determine best fitting fixed effects structure
```{r setup_fe_ov}
# Formula of optimal random effects structure
re.ov.optim <- MeanODBA ~ (1|DeployID)
# List to store fixed effects model formulae
me.ov.form <- list(list(~ . + poly(Tailwind, 2) * Crosswind, re.ov.optim),
                   list(~ . + poly(Tailwind, 2) + Crosswind, re.ov.optim),
                   list(~ . + poly(Tailwind, 2), re.ov.optim),
                   list(~ . + Crosswind, re.ov.optim))
```

```{r fit_me_ov, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
me.ov.mod <- foreach(f = me.ov.form) %dopar% {
  # Update 
  mod.formula <- update.formula(f[[2]], f[[1]])
  tryCatch(glmmadmb(mod.formula, segSample, family = 'gaussian'), error = function(e) NULL)
}
stopCluster(modCl)

# Save mixed effects models
save(me.ov.mod, file = '../data/out/Models/MEOVmodels.RData')
```

```{r summarize_me_ov}
load('../data/out/Models/MEOVmodels.RData')
# Summarize models by AIC
me.ov.summ <- foreach(f = me.ov.form,
                      m = me.ov.mod, 
                      .combine = rbind) %do% {
  fe.ov.formula <- char.formula(f[[1]])
  re.ov.formula <- char.formula(f[[2]])
  
  if(is.null(m)) {
    data.frame(FixedEffects = fe.ov.formula,
               RandomEffects = re.ov.formula,
               AIC = NA)
  } else {
    data.frame(FixedEffects = fe.ov.formula,
               RandomEffects = re.ov.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(me.ov.summ, digits = 3)
```

# Model Fitting (OS)
## Determine optimal random effects structure (from DeployID, Leg)

```{r setup_re_os}
fe.os.max <- MeanODBA ~ poly(WindAngle, 2) * WindSpd
re.os.form <- list(# Intercepts
                   ~ . + (1|DeployID),
                   ~ . + (1|Leg))
```

```{r fit_re_os, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
re.os.mod <- foreach(f = re.os.form) %dopar% {
  mod.formula <- update.formula(fe.os.max, f)
  tryCatch(glmmadmb(mod.formula, segSample, family = 'gaussian'), error = function(e) NULL)
}
stopCluster(modCl)

# Save random effects models
save(re.os.mod, file = '../data/out/Models/REOSmodels.RData')
```

```{r summarize_re_os}
load('../data/out/Models/REOSmodels.RData')
# Summarize models by AIC
re.os.summ <- foreach(f = re.os.form,
                   m = re.os.mod, 
                   .combine = rbind) %do% {
  re.os.formula <- char.formula(f)
  if(is.null(m)) {
    data.frame(Formula = re.os.formula,
               AIC = NA)
  } else {
    data.frame(Formula = re.os.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(re.os.summ, digits = 3)
```

Based on AIC the top ranked FV random effects structure is (1|B).

## Determine optimal fixed effects structure
Using the optimal random effects structure, determine best fitting fixed effects structure
```{r setup_fe_os}
# Formula of optimal random effects structure
re.os.optim <- MeanODBA ~ (1|DeployID)
# List to store fixed effects model formulae
me.os.form <- list(list(~ . + poly(WindAngle, 2) * WindSpd, re.os.optim),
                   list(~ . + poly(WindAngle, 2) + WindSpd, re.os.optim),
                   list(~ . + WindSpd, re.os.optim),
                   list(~ . + poly(WindAngle, 2), re.os.optim))
```

```{r fit_me_os, eval = FALSE}
# Fit models
modCl <- makeCluster(detectCores() - 1, type = 'FORK')
registerDoParallel(modCl)
me.os.mod <- foreach(f = me.os.form) %dopar% {
  # Update 
  mod.formula <- update.formula(f[[2]], f[[1]])
  tryCatch(glmmadmb(mod.formula, segSample, family = 'gaussian'), error = function(e) NULL)
}
stopCluster(modCl)

# Save mixed effects models
save(me.os.mod, file = '../data/out/Models/MEOSmodels.RData')
```

```{r summarize_me_os}
load('../data/out/Models/MEOSmodels.RData')
# Summarize models by AIC
me.os.summ <- foreach(f = me.os.form,
                      m = me.os.mod, 
                      .combine = rbind) %do% {
  fe.os.formula <- char.formula(f[[1]])
  re.os.formula <- char.formula(f[[2]])
  
  if(is.null(m)) {
    data.frame(FixedEffects = fe.os.formula,
               RandomEffects = re.os.formula,
               AIC = NA)
  } else {
    data.frame(FixedEffects = fe.os.formula,
               RandomEffects = re.os.formula,
               AIC = AIC(m))
  }
} %>%
  mutate(dAIC = AIC - min(AIC, na.rm = TRUE),
         rellik = exp(-0.5 * dAIC),
         AICw = rellik/sum(rellik, na.rm = TRUE)) %>%
  select(-rellik) %>%
  arrange(dAIC)

# Print table
kable(me.os.summ, digits = 3)
```

# Model comparison
```{r mod_comp}
# FV model: FlapRatio ~ poly(Tailwind, 2) + (1|DeployID)
fv.mod <- me.fv.mod[[3]]
# FS model: FlapRatio ~ poly(WindAngle, 2) + WindSpd + (1|DeployID)
fs.mod <- me.fs.mod[[2]]
# OV model: MeanODBA ~ poly(Tailwind, 2) * Crosswind + (1|DeployID)
ov.mod <- me.ov.mod[[1]]
# OS model: MeanODBA ~ poly(WindAngle, 2) + WindSpd + (1|DeployID)
os.mod <- me.os.mod[[2]]

AIC(fv.mod, fs.mod)
AIC(ov.mod, os.mod)

viz.model <- function(model) {
  grain <- 20
  response <- lhs(formula(model))
  
  if(!is.na(grep('Tailwind', rhs(formula(model))) || 
            grep('Crosswind', rhs(formula(model))))) {
    predX <- 'Tailwind'
    predY <- 'Crosswind'
    x <- seq(-12, 12, length.out = grain)
    y <- seq(0, 12, length.out = grain)
  } else {
    predX <- 'WindAngle'
    predY <- 'WindSpd'
    x <- seq(0, pi, length.out = grain)
    y <- seq(0, 15, length.out = grain)
  }
  
  data <- expand.grid(x = x, y = y) %>%
    rename(!!predX := x, !!predY := y) %>%
    mutate(!!response := predict(model, newdata = ., type = 'response'))
  
  p <- ggplot(data, aes_(x = as.name(predX), y = as.name(predY))) +
    geom_raster(aes_(fill = as.name(response))) +
    geom_contour(aes_(z = as.name(response))) +
    labs(title = format(formula(model))) + 
    theme(plot.title = element_text(size = 10))
  
  if(predX == 'WindAngle') {
    p + scale_x_continuous(breaks = pi/4 *0:4,
                           labels = c('0', 'pi/4', 'pi/2', '3pi/4', 'pi'),
                           name = 'Tailwind  <---  Wind Angle  --->  Headwind')
  } else {
    p
  }
}

viz.model(fv.mod)
viz.model(fs.mod)
viz.model(ov.mod)
viz.model(os.mod)
```

OS outperforms OV and FS outperforms FV. 

```{r groundspeed}
ggplot(segSample, aes(x = Tailwind, y = meanSpd)) +
  geom_point(aes(color = DeployID)) +
  geom_smooth(color = 'blue', se = FALSE) +
  geom_smooth(color = 'red', se = FALSE, method = lm, formula = y ~ x) +
  geom_smooth(color = 'green', se = FALSE, method = lm, formula = y ~ poly(x, 2))

grdspd.mod <- glmmadmb(meanSpd ~ poly(Tailwind, 2) + (1|DeployID), data = segSample, family = 'gaussian')

segSample %>%
  mutate(predicted = predict(grdspd.mod, type = 'response')) %>%
  ggplot(aes(x = Tailwind, y = predicted)) +
  geom_point(data = segSample, aes(y = meanSpd)) +
  geom_line() + 
  labs(x = 'Tailwind (m/s)',
       y = 'Ground speed (m/s)') +
  coord_fixed() + 
  expand_limits(y = c(9, 15))
```

```{r trip_az, eval = FALSE}
# ODBA cost of parallel vs perpendicular trips in 8m/s winds over 50km
d <- 50e3
example.data <- data.frame(WindAngleOut = seq(0, pi/2, length.out = 10),
                           WindSpd = 8) %>%
  mutate(WindAngleIn = pi - WindAngleOut,
         TailwindOut = WindSpd * cos(WindAngleOut),
         TailwindIn = WindSpd * cos(WindAngleIn))

fitted.data <- example.data %>%
  mutate(ODBAout = predict(os.mod, 
                           newdata = rename(example.data, WindAngle = WindAngleOut), 
                           type = 'response'),
         ODBAin = predict(os.mod, 
                          newdata = rename(example.data, WindAngle = WindAngleIn), 
                          type = 'response'),
         GrdSpdOut = predict(grdspd.mod, 
                             newdata = rename(example.data, Tailwind = TailwindOut),
                             type = 'response'),
         GrdSpdIn = predict(grdspd.mod, 
                             newdata = rename(example.data, Tailwind = TailwindIn),
                             type = 'response'),
         DurationOut = d / GrdSpdOut,
         DurationIn = d / GrdSpdIn,
         EnergyOut = DurationOut * ODBAout,
         EnergyIn = DurationIn * ODBAin,
         EnergyTotal = EnergyOut + EnergyIn)

gather(example.data, ODBAdir, ODBAval, ODBAout:ODBAin) %>%
  ggplot(aes(x = WindAngleOut, y = ODBAval, color = ODBAdir)) + 
  geom_line() + 
  scale_x_continuous(breaks = pi/8 * 0:4,
                     labels = c('0', 'pi/8', 'pi/4', '3pi/4', 'pi/2'),
                     name = 'Tailwind  <---  Wind Angle  --->  Crosswind') +
  labs(y = 'Mean ODBA (m/s^2)')

gather(example.data, GrdSpdDir, GrdSpdVal, GrdSpdOut:GrdSpdIn) %>%
  ggplot(aes(x = WindAngleOut, y = GrdSpdVal, color = GrdSpdDir)) + 
  geom_line() + 
  scale_x_continuous(breaks = pi/8 * 0:4,
                     labels = c('0', 'pi/8', 'pi/4', '3pi/4', 'pi/2'),
                     name = 'Tailwind  <---  Wind Angle  --->  Crosswind') +
  labs(y = 'Ground Speed (m/s)')

gather(example.data, DurationDir, DurationVal, DurationOut:DurationIn) %>%
  ggplot(aes(x = WindAngleOut, y = DurationVal / 3600, color = DurationDir)) + 
  geom_line() + 
  scale_x_continuous(breaks = pi/8 * 0:4,
                     labels = c('0', 'pi/8', 'pi/4', '3pi/4', 'pi/2'),
                     name = 'Tailwind  <---  Wind Angle  --->  Crosswind') +
  labs(y = 'Duration (hours)')

gather(example.data, EnergyDir, EnergyVal, EnergyOut:EnergyTotal) %>%
  ggplot(aes(x = WindAngleOut, y = EnergyVal, color = EnergyDir)) + 
  geom_line() + 
  scale_x_continuous(breaks = pi/8 * 0:4,
                     labels = c('0', 'pi/8', 'pi/4', '3pi/4', 'pi/2'),
                     name = 'Tailwind  <---  Wind Angle  --->  Crosswind') +
  labs(y = 'Energy')
```